---
phase: 12-dish-images
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260228230000_dish_images.sql
  - lib/images.ts
  - lib/image-utils.ts
  - lib/types/menu.ts
  - next.config.ts
  - app/api/scan/url/route.ts
  - app/api/scan/photo/route.ts
  - app/api/enrichment/status/route.ts
autonomous: true
requirements: [ENRI-05]
user_setup:
  - service: unsplash
    why: "Primary stock photo source for dish images"
    env_vars:
      - name: UNSPLASH_ACCESS_KEY
        source: "https://unsplash.com/developers → Your Apps → New Application → Access Key"
    dashboard_config:
      - task: "Create an application on Unsplash Developers"
        location: "https://unsplash.com/developers → New Application → Accept guidelines → Copy Access Key"
      - task: "Apply for Production (5,000 req/hr vs 50 demo)"
        location: "https://unsplash.com/developers → Your App → Request Production"
  - service: pexels
    why: "Fallback stock photo source when Unsplash has no result or rate limited"
    env_vars:
      - name: PEXELS_API_KEY
        source: "https://www.pexels.com/api/new/ → Generate API Key"

must_haves:
  truths:
    - "fetchDishImages runs after enrichDishBatch via after() in all scan routes"
    - "Unsplash is queried first; Pexels is queried only when Unsplash returns no result or is rate-limited"
    - "Two dishes with the same canonical_name share one image (no duplicate API call)"
    - "Image URL, source, credit, credit URL, and placeholder are stored per menu_item"
    - "Beverages are skipped in image fetch (same as enrichment)"
    - "Enrichment status polling response includes image fields"
  artifacts:
    - path: "supabase/migrations/20260228230000_dish_images.sql"
      provides: "5 new columns on menu_items"
      contains: "image_url"
    - path: "lib/images.ts"
      provides: "fetchDishImages, fetchFromUnsplash, fetchFromPexels"
      exports: ["fetchDishImages"]
    - path: "lib/image-utils.ts"
      provides: "hexToDataURL, buildImageQuery utility functions"
      exports: ["hexToDataURL", "buildImageQuery"]
    - path: "lib/types/menu.ts"
      provides: "MenuItem with image_url, image_source, image_credit, image_credit_url, image_placeholder"
      contains: "image_url"
  key_links:
    - from: "app/api/scan/url/route.ts"
      to: "lib/images.ts"
      via: "after() callback chaining fetchDishImages after enrichDishBatch"
      pattern: "await fetchDishImages"
    - from: "lib/images.ts"
      to: "supabase menu_items"
      via: "supabaseAdmin update with image fields"
      pattern: "supabaseAdmin.*from.*menu_items.*update"
    - from: "app/api/enrichment/status/route.ts"
      to: "menu_items image columns"
      via: "SELECT includes image_url, image_source, image_credit, image_credit_url, image_placeholder"
      pattern: "image_url"
---

<objective>
Build the dish image fetch pipeline: DB schema, Unsplash/Pexels API integration, scan route wiring, and enrichment status endpoint extension.

Purpose: Store a licensed stock photo per enriched dish, fetched asynchronously after enrichment completes, with proper attribution data for Unsplash/Pexels API compliance.
Output: `lib/images.ts` fire-and-forget pipeline, SQL migration, updated scan routes, image fields in polling response.
</objective>

<execution_context>
@/Users/ekitcho/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ekitcho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-dish-images/12-RESEARCH.md
@.planning/phases/11-dish-enrichment/11-01-SUMMARY.md
@lib/enrichment.ts
@lib/types/menu.ts
@lib/types/llm.ts
@app/api/scan/url/route.ts
@app/api/scan/photo/route.ts
@app/api/enrichment/status/route.ts
@next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQL migration + MenuItem type + image utilities + next.config</name>
  <files>
    supabase/migrations/20260228230000_dish_images.sql
    lib/types/menu.ts
    lib/image-utils.ts
    next.config.ts
  </files>
  <action>
1. **SQL migration** (`supabase/migrations/20260228230000_dish_images.sql`):
   Add 5 columns to `menu_items` using `ALTER TABLE ... ADD COLUMN IF NOT EXISTS`:
   - `image_url TEXT` — hotlinked Unsplash/Pexels URL
   - `image_source TEXT` — `'unsplash'` or `'pexels'`
   - `image_credit TEXT` — display text e.g. "Photo by Jane on Unsplash"
   - `image_credit_url TEXT` — photographer profile URL with UTM params
   - `image_placeholder TEXT` — data URL for blur-up placeholder (1x1 BMP from dominant color)

2. **MenuItem interface** (`lib/types/menu.ts`):
   Add 5 fields after `enriched_at`:
   ```typescript
   image_url: string | null;
   image_source: string | null;       // 'unsplash' | 'pexels'
   image_credit: string | null;
   image_credit_url: string | null;
   image_placeholder: string | null;  // data:image/bmp;base64,... for blur-up
   ```

3. **Image utilities** (`lib/image-utils.ts`):
   - `hexToDataURL(hex: string): string` — converts a hex color string (e.g. "#A08060") to a 1x1 BMP data URL. Used for both Unsplash `photo.color` and Pexels `photo.avg_color` as blur-up placeholders. Implementation: build a 58-byte BMP manually (14-byte file header + 40-byte DIB header + 4-byte pixel data BGR+pad), encode as base64. No external dependencies needed. See research Pattern 4 for exact byte array.
   - `buildImageQuery(canonicalName: string | null, nameOriginal: string, origin: string | null): string` — constructs search query for stock photo APIs. Uses canonical name (or falls back to name_original), appends first segment of origin (before comma) if < 30 chars, always appends "food" or "food dish". See research code examples section for exact logic.

4. **next.config.ts**:
   Add Pexels to `remotePatterns` array:
   ```typescript
   {
     protocol: 'https',
     hostname: 'images.pexels.com',
     pathname: '/photos/**',
   },
   ```
  </action>
  <verify>
- `npx tsc --noEmit` passes with zero errors
- `lib/image-utils.ts` exports `hexToDataURL` and `buildImageQuery`
- `next.config.ts` has both `images.unsplash.com` and `images.pexels.com` in remotePatterns
- MenuItem interface has all 5 image fields
  </verify>
  <done>
SQL migration file exists with 5 ADD COLUMN IF NOT EXISTS statements. MenuItem has 5 image fields. hexToDataURL converts hex to data URL. buildImageQuery produces sensible search strings. Pexels hostname in next.config.ts remotePatterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: lib/images.ts + scan route wiring + status endpoint update</name>
  <files>
    lib/images.ts
    app/api/scan/url/route.ts
    app/api/scan/photo/route.ts
    app/api/enrichment/status/route.ts
  </files>
  <action>
1. **Install blurhash** (needed for future blurhash decode but also validates the import):
   ```bash
   npm install blurhash
   ```
   Note: For this plan, we use `hexToDataURL` (simpler, works server-side) for the blur placeholder rather than full blurhash decode. The `blurhash` package is installed for potential future use but the primary placeholder strategy is dominant-color-based (Unsplash `photo.color`, Pexels `photo.avg_color`).

2. **`lib/images.ts`** — server-only module mirroring `lib/enrichment.ts` pattern:
   - Start with `import 'server-only';`
   - Import `supabaseAdmin` from `@/lib/supabase-admin`
   - Import `hexToDataURL`, `buildImageQuery` from `@/lib/image-utils`

   **Type:**
   ```typescript
   interface ImageResult {
     url: string;
     placeholder: string;  // data URL for blur-up
     credit: string;
     creditUrl: string;
     source: 'unsplash' | 'pexels';
   }
   ```

   **`fetchFromUnsplash(query: string): Promise<ImageResult | null>`:**
   - Read `process.env.UNSPLASH_ACCESS_KEY`. If missing, return null.
   - GET `https://api.unsplash.com/search/photos` with params: `query`, `per_page=5`, `orientation=squarish`, `content_filter=high`.
   - Header: `Authorization: Client-ID ${key}`.
   - If `!res.ok`, return null. Check `X-Ratelimit-Remaining` header — if < 5, log warning and return null (let caller fall through to Pexels).
   - Take first result (`data.results[0]`). If none, return null.
   - Fire-and-forget download tracking: `fetch(photo.links.download_location, { headers: { Authorization: \`Client-ID ${key}\` } }).catch(() => {})` — required by Unsplash API guidelines.
   - Return `ImageResult` with:
     - `url`: `photo.urls.small` (400px — mobile card)
     - `placeholder`: `hexToDataURL(photo.color)` (dominant color hex)
     - `credit`: `Photo by ${photo.user.name} on Unsplash`
     - `creditUrl`: `https://unsplash.com/@${photo.user.username}?utm_source=nomnomnom&utm_medium=referral`
     - `source`: `'unsplash'`

   **`fetchFromPexels(query: string): Promise<ImageResult | null>`:**
   - Read `process.env.PEXELS_API_KEY`. If missing, return null.
   - GET `https://api.pexels.com/v1/search` with params: `query`, `per_page=5`, `orientation=square`.
   - Header: `Authorization: ${key}` (no prefix — Pexels uses raw key).
   - Take first result (`data.photos[0]`). If none, return null.
   - Return `ImageResult` with:
     - `url`: `photo.src.medium`
     - `placeholder`: `hexToDataURL(photo.avg_color)`
     - `credit`: `Photo by ${photo.photographer} on Pexels`
     - `creditUrl`: `${photo.photographer_url}?utm_source=nomnomnom`
     - `source`: `'pexels'`

   **`fetchDishImages(menuId: string): Promise<void>`** (exported, main entry point):
   - Wrapped in top-level try/catch — never throws (fire-and-forget safety).
   - Query `menu_items` for items matching: `menu_id = menuId`, `is_beverage = false`, `enrichment_status = 'enriched'`, `enrichment_depth = 'full'`, `image_url IS NULL`.
   - If no items, return early.
   - For each item:
     a. **Canonical name deduplication**: Before calling external API, check if another `menu_item` with the same `canonical_name` (not null) already has an `image_url`. If yes, copy all 5 image fields from the existing record — zero API cost. Continue to next item.
     b. Build query: `buildImageQuery(item.canonical_name, item.name_original, item.enrichment_origin)`.
     c. Fetch: `const result = await fetchFromUnsplash(query) ?? await fetchFromPexels(query);`
     d. If result found: update `menu_items` with `image_url`, `image_source`, `image_credit`, `image_credit_url`, `image_placeholder` via `supabaseAdmin`.
     e. If no result: leave `image_url` null — UI will render gradient+emoji fallback.
   - Per-item try/catch inside the loop — one failure doesn't stop processing.

3. **Scan route wiring** — both `app/api/scan/url/route.ts` and `app/api/scan/photo/route.ts`:
   - Import `fetchDishImages` from `@/lib/images`.
   - In every `after(async () => { ... })` callback that chains `generateCanonicalNames` then `enrichDishBatch`, add `await fetchDishImages(menu.id);` as the third step after `enrichDishBatch`. This ensures images are fetched only after enrichment completes (needs `enrichment_status`, `enrichment_depth`, `enrichment_origin`).
   - There are 5 such `after()` blocks in `url/route.ts` (eazee-link cache hit backfill, eazee-link fresh, generic text, PDF, screenshot) and 1 in `photo/route.ts`. Add `fetchDishImages` to all 6. Note: the eazee-link cache hit backfill path (line ~72) does NOT chain enrichment — skip that one. Only add to the 5 paths that chain `enrichDishBatch`.

4. **Enrichment status endpoint** (`app/api/enrichment/status/route.ts`):
   - Add `image_url, image_source, image_credit, image_credit_url, image_placeholder` to the `.select()` string.
   - This allows the polling hook to pick up image data as it arrives, and the polling can continue until full-depth items have non-null `image_url`.
  </action>
  <verify>
- `npx tsc --noEmit` passes with zero errors
- `npm run build` passes
- `lib/images.ts` exports `fetchDishImages`
- `fetchDishImages` imported and called in all scan route `after()` blocks that chain enrichDishBatch
- Status endpoint SELECT includes all 5 image columns
- `package.json` includes `blurhash` dependency
  </verify>
  <done>
`fetchDishImages` is a fire-and-forget pipeline that queries Unsplash then Pexels for each full-depth enriched food item, stores image URL + attribution in DB, deduplicates by canonical name, and is chained after `enrichDishBatch` in all scan routes. The enrichment status endpoint returns image fields for the polling hook to consume.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero errors
2. `npm run build` — all pages build
3. SQL migration has 5 `ADD COLUMN IF NOT EXISTS` statements
4. `fetchDishImages` exported from `lib/images.ts`
5. All scan route `after()` blocks chain `fetchDishImages` after `enrichDishBatch`
6. Status endpoint SELECT includes `image_url, image_source, image_credit, image_credit_url, image_placeholder`
7. `next.config.ts` remotePatterns includes both Unsplash and Pexels hostnames
</verification>

<success_criteria>
- Backend image pipeline complete: Unsplash → Pexels → null (no API result) chain works
- DB schema supports all attribution fields required by both Unsplash and Pexels API terms
- Canonical name deduplication prevents wasted API calls for identical dishes
- Image fetch is async (after()) and never blocks the scan response
- Polling endpoint exposes image data for the UI to consume
</success_criteria>

<output>
After completion, create `.planning/phases/12-dish-images/12-01-SUMMARY.md`
</output>
