---
phase: 05-scan-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/scan/page.tsx
  - app/menu/[id]/page.tsx
  - components/scan/ScanTabs.tsx
  - components/scan/QrScanner.tsx
  - components/scan/UrlInput.tsx
  - components/scan/PhotoUpload.tsx
  - components/scan/ScanProgress.tsx
autonomous: false
requirements: [SCAN-01, SCAN-04, INFR-04]

must_haves:
  truths:
    - "User sees a /scan page with three tabs: QR, URL, Photo"
    - "User can paste a URL and submit it — request goes to POST /api/scan/url and redirects to /menu/[id]"
    - "User can open camera to scan a QR code — decoded URL routes through the URL scan pipeline"
    - "User can select or capture a photo — image is resized to 1024px max client-side before upload"
    - "User sees step-by-step progress feedback during the 6-15s parsing pipeline — never a blank screen"
    - "/menu/[id] page exists and loads menu data from Supabase by ID"
  artifacts:
    - path: "app/scan/page.tsx"
      provides: "Scan page with tab layout"
      min_lines: 20
    - path: "app/menu/[id]/page.tsx"
      provides: "Menu display page (data loading stub for Phase 6)"
      min_lines: 15
    - path: "components/scan/ScanTabs.tsx"
      provides: "Tab switcher component for QR/URL/Photo"
      min_lines: 20
    - path: "components/scan/QrScanner.tsx"
      provides: "In-browser QR scanner using qr-scanner library"
      contains: "import('qr-scanner')"
    - path: "components/scan/UrlInput.tsx"
      provides: "URL paste input with submit"
      contains: "api/scan/url"
    - path: "components/scan/PhotoUpload.tsx"
      provides: "Photo upload with client-side resize (INFR-04)"
      contains: "maxWidthOrHeight.*1024"
    - path: "components/scan/ScanProgress.tsx"
      provides: "Multi-step loading indicator"
      min_lines: 15
  key_links:
    - from: "components/scan/UrlInput.tsx"
      to: "/api/scan/url"
      via: "fetch POST"
      pattern: "fetch.*api/scan/url"
    - from: "components/scan/PhotoUpload.tsx"
      to: "/api/scan/photo"
      via: "fetch POST with FormData"
      pattern: "fetch.*api/scan/photo"
    - from: "components/scan/QrScanner.tsx"
      to: "components/scan/UrlInput.tsx"
      via: "onResult callback feeds decoded URL into URL scan flow"
      pattern: "onResult"
    - from: "components/scan/PhotoUpload.tsx"
      to: "browser-image-compression"
      via: "imageCompression import for INFR-04 resize"
      pattern: "imageCompression.*maxWidthOrHeight"
    - from: "app/menu/[id]/page.tsx"
      to: "lib/supabase"
      via: "Supabase query for menu + items by ID"
      pattern: "supabase.*from.*menus"
---

<objective>
Build the scan page UI with three tab-based input methods (QR, URL, Photo), a multi-step progress indicator, and a `/menu/[id]` stub page that loads and displays menu data from Supabase.

Purpose: This is the user-facing half of the scan pipeline. Users interact with the /scan page to initiate menu parsing, see progress feedback during the 6-15 second pipeline, and land on /menu/[id] with their parsed data. The QR scanner decodes URLs and feeds them through the URL path. The photo uploader resizes images to 1024px max (INFR-04) before sending. The menu page is a minimal but functional data-loading page — full dish card design is Phase 6.

Output: Functional /scan page with all three methods wired to the API routes from Plan 01, a progress indicator, and a /menu/[id] page showing the parsed result.
</objective>

<execution_context>
@/Users/ekitcho/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ekitcho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-scan-pipeline/05-RESEARCH.md
@.planning/phases/05-scan-pipeline/05-01-SUMMARY.md
@app/globals.css
@app/layout.tsx
@components/layout/Nav.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scan page and input components</name>
  <files>
    app/scan/page.tsx
    components/scan/ScanTabs.tsx
    components/scan/QrScanner.tsx
    components/scan/UrlInput.tsx
    components/scan/PhotoUpload.tsx
    components/scan/ScanProgress.tsx
  </files>
  <action>
**Create `components/scan/ScanTabs.tsx`** — `'use client'`
- A tab bar with three tabs: "QR Code", "URL", "Photo"
- State: `activeTab: 'qr' | 'url' | 'photo'` (default to `'url'` — most common path)
- Render the active tab's content component below the tab bar
- Mobile-first styling with Tailwind: full-width tabs, clear active state using brand orange (`text-brand-orange`, `border-brand-orange`)
- On mobile, include a note above the QR tab content: "On mobile, point your camera app at the QR code — it opens automatically." (per research Pitfall 1 — native camera handles QR on mobile)
- Pass shared state down: `scanState: 'idle' | 'scanning' | 'error'`, `error: string | null`, `currentStep: number`
- When any method submits, the tab switches to showing `<ScanProgress>` overlay

**Create `components/scan/UrlInput.tsx`** — `'use client'`
- Text input with placeholder "Paste a menu URL (e.g. https://menu.example.com)"
- "Scan" submit button (disabled when input is empty or during scan)
- On submit:
  1. Set parent state to `scanning`
  2. `fetch('/api/scan/url', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ url }) })`
  3. On success: `router.push(\`/menu/\${menuId}\`)`
  4. On error: set `error` state with the error message from the response
- Use `useRouter` from `next/navigation` for client-side redirect
- Style: dark input field matching brand theme, orange submit button

**Create `components/scan/QrScanner.tsx`** — `'use client'`
- Uses `qr-scanner` library via dynamic import in `useEffect` (browser APIs only — see research Pattern 3)
- Props: `onResult: (url: string) => void`
- On mount: `import('qr-scanner').then(...)` to create scanner with `preferredCamera: 'environment'`, `highlightScanRegion: true`, `highlightCodeOutline: true`
- On QR decode: call `onResult(result.data)`, stop scanner
- On unmount: `scanner?.destroy()` in cleanup
- Render a `<video>` element styled to fit the container (max height ~300px on mobile)
- Show a brief "Scanning..." text below the video
- When `onResult` fires, the parent component routes the decoded URL through the same URL scan flow (fetch to `/api/scan/url`)

**Create `components/scan/PhotoUpload.tsx`** — `'use client'`
- File input that accepts `image/*` with a styled button "Take Photo or Choose File"
- Also support camera capture: add `capture="environment"` attribute for mobile devices
- On file selection:
  1. Show a small preview thumbnail of the selected image
  2. Compress with `browser-image-compression`:
     ```typescript
     import imageCompression from 'browser-image-compression';
     const compressed = await imageCompression(file, {
       maxWidthOrHeight: 1024,  // INFR-04: hard requirement
       useWebWorker: true,
       maxSizeMB: 2,
       fileType: 'image/jpeg',
     });
     ```
  3. On "Upload & Scan" button click:
     - Create FormData, append compressed file as `'image'`
     - `fetch('/api/scan/photo', { method: 'POST', body: formData })` — do NOT set Content-Type header (browser sets multipart boundary automatically — research Pitfall 3)
     - On success: `router.push(\`/menu/\${menuId}\`)`
     - On error: show error message

**Create `components/scan/ScanProgress.tsx`** — `'use client'`
- Multi-step progress indicator with 4 steps:
  1. "Reading menu..." (icon: magnifying glass or similar via Unicode)
  2. "Identifying dishes..." (icon: fork/knife or similar)
  3. "Translating..." (icon: globe or similar)
  4. "Almost done!" (icon: checkmark)
- Props: `currentStep: number` (0-3), `isComplete: boolean`
- Each step shows: step label, active/completed/pending state
- Active step has a subtle pulse animation (use Tailwind `animate-pulse`)
- Completed steps show a checkmark
- Style: centered, stacked vertically, dark background matching brand theme
- The parent component advances `currentStep` on a 3-second timer while the API request runs. If the request completes before the timer, immediately jump to the last step. If the request takes longer than 15s, show "Still working on it..." message.

**Create `app/scan/page.tsx`**
- This is a Server Component wrapper that renders the client `<ScanTabs>` component
- Minimal: just a page title "Scan a Menu" and the tabs component
- Use the brand styling: dark background, centered content, mobile-first max-width
- Add metadata export: `title: 'Scan a Menu | NOM'`

Create the `components/scan/` directory.
  </action>
  <verify>
1. `npm run build` passes
2. All 6 files exist in the correct paths
3. `PhotoUpload.tsx` contains `maxWidthOrHeight: 1024` (INFR-04)
4. `QrScanner.tsx` uses dynamic `import('qr-scanner')` (not static import at top level)
5. `UrlInput.tsx` fetches `/api/scan/url`
6. No `Content-Type` header set in PhotoUpload's fetch call
  </verify>
  <done>
/scan page renders with three tabs (QR, URL, Photo). URL tab accepts and submits a URL. QR tab opens camera and decodes QR codes. Photo tab captures/selects an image, resizes to 1024px max (INFR-04), and uploads. Progress indicator shows multi-step feedback during parsing. All methods redirect to /menu/[id] on success.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /menu/[id] stub page with data loading</name>
  <files>
    app/menu/[id]/page.tsx
  </files>
  <action>
Create `app/menu/[id]/page.tsx` — a **Server Component** that loads menu data from Supabase and displays it.

This is a functional stub — it loads and renders the data, but the full dish card design is Phase 6. For now, display enough to prove the pipeline works end-to-end.

Implementation:
- Import `supabase` from `@/lib/supabase` (anon client for reads)
- Import `MenuWithItems` from `@/lib/types/menu`
- Use the Next.js App Router dynamic route params: `{ params }: { params: Promise<{ id: string }> }` (Next.js 16 pattern — params is a Promise)
- Await params: `const { id } = await params`
- Query Supabase: `supabase.from('menus').select('*, menu_items(*)').eq('id', id).single()`
- If no data found: use `notFound()` from `next/navigation` to show 404
- Display:
  - Page title: "Menu" or restaurant name if available from `menu.raw_text` first line
  - Source badge: show `menu.source_type` (url/photo/qr)
  - Dish count: "X dishes found"
  - Simple dish list: For each `menu_item` in `menu.menu_items`, render:
    - `dish_name` (original)
    - `description_original` if present
    - `price` if present
    - `trust_signal` badge (green checkmark for "verified", orange warning for "inferred")
    - `allergens` as small tags
    - `translations.fr` and `translations.en` names as secondary text
  - Style with Tailwind: card-like items on dark background, brand colors
  - This is intentionally minimal — Phase 6 replaces it with full dish card components

- Add `generateMetadata` export for dynamic page title

Create the `app/menu/[id]/` directory.
  </action>
  <verify>
1. `npm run build` passes
2. `app/menu/[id]/page.tsx` exists
3. Page queries Supabase by menu ID
4. Page uses `notFound()` for missing menus
5. Page renders dish data from `menu_items`
  </verify>
  <done>
/menu/[id] page exists as a Server Component that loads a menu and its items from Supabase, displays dish names, prices, translations, allergens, and trust signals. Returns 404 for invalid IDs. Ready to be the redirect target for the scan pipeline.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify scan flow end-to-end</name>
  <files>app/scan/page.tsx</files>
  <action>
Human verification checkpoint — no automated work. Verify the complete scan pipeline end-to-end.

What was built: Complete scan pipeline: /scan page with QR/URL/Photo tabs, API route handlers for URL and photo parsing, Screenshotone text extraction, GPT-4o Vision OCR, progress indicator, and /menu/[id] display page.
  </action>
  <how-to-verify>
**Prerequisites:** Ensure these env vars are set in `.env.local`:
- `SCREENSHOTONE_ACCESS_KEY` and `SCREENSHOTONE_SECRET_KEY` (from screenshotone.com dashboard)
- `OPENAI_API_KEY` (from OpenAI)
- `SUPABASE_SERVICE_ROLE_KEY` (from Supabase dashboard)
- Supabase schema has been applied (run `supabase/schema.sql` in SQL Editor)

**Test 1 — URL Scan (SCAN-02):**
1. Run `npm run dev`
2. Open `http://localhost:3000/scan` on your phone or browser
3. Click the "URL" tab
4. Paste: `https://menu.eazee-link.com/?id=E7FNRP0ET3&o=q`
5. Click "Scan"
6. Verify: progress steps appear (Reading menu... -> Identifying dishes... -> Translating...)
7. Verify: redirected to `/menu/[id]` with dish data displayed

**Test 2 — Cache Hit (SCAN-05):**
1. Go back to `/scan`
2. Paste the same URL again
3. Verify: result appears almost instantly (no progress steps needed — cached)

**Test 3 — Photo Scan (SCAN-03 + INFR-04):**
1. On the /scan page, click "Photo" tab
2. Take a photo of any restaurant menu (or use a menu image from the web)
3. Verify: preview appears, then click upload
4. Verify: progress steps appear
5. Verify: redirected to `/menu/[id]` with extracted dishes

**Test 4 — QR Scan (SCAN-01) — desktop or mobile:**
1. Click "QR Code" tab
2. If on desktop with a webcam: point a QR code at the camera
3. Verify: decoded URL triggers the URL scan flow
4. (On mobile: the native camera app handles QR — the in-app scanner is a fallback)

**Test 5 — Loading UX (SCAN-04):**
1. During any scan, verify that the progress indicator is visible and updating — no blank screen at any point
  </how-to-verify>
  <verify>All 5 manual tests pass as described above</verify>
  <done>User has confirmed all scan methods work end-to-end: URL scan, photo scan, QR scan, cache hit, and loading UX</done>
  <resume-signal>Type "approved" if all 5 tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. `/scan` page renders with three functional tabs
3. URL scan through Screenshotone produces a valid `/menu/[id]` page
4. Photo scan through GPT-4o Vision produces a valid `/menu/[id]` page
5. QR scanner activates camera and decodes QR codes
6. Progress indicator shows during all scan methods
7. Second scan of same URL returns cached result instantly
8. Photos are resized to 1024px max before upload (check Network tab — file size should be <500KB for a phone photo)
</verification>

<success_criteria>
- All three scan methods (QR, URL, photo) produce a valid menu page
- Loading progress is visible during parsing — user never sees a blank screen
- Photo upload resizes to 1024px max client-side (INFR-04)
- Cached URLs return instantly on repeat scan (SCAN-05)
- Mobile-first layout works on phone screens
</success_criteria>

<output>
After completion, create `.planning/phases/05-scan-pipeline/05-02-SUMMARY.md`
</output>
