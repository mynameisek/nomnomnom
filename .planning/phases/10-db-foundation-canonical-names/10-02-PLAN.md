---
phase: 10-db-foundation-canonical-names
plan: 02
type: execute
wave: 2
depends_on:
  - "10-01"
files_modified:
  - lib/canonical.ts
  - lib/cache.ts
  - app/api/scan/url/route.ts
  - app/api/scan/photo/route.ts
  - supabase/migrations/20260228210000_known_dishes_seed.sql
autonomous: true
requirements:
  - KNOW-01
  - KNOW-02
  - KNOW-03
  - KNOW-04

must_haves:
  truths:
    - "Scanning a Turkish menu produces canonical_name values stored in menu_items rows"
    - "Re-scanning the same URL returns cached canonical names without a new LLM call"
    - "Beverages receive is_beverage=true and enrichment_status='pending'; food items receive enrichment_status='pending' (is_beverage flag signals deprioritization to Phase 11)"
    - "Canonical name generation runs inside after() and does not block the scan HTTP response"
    - "known_dishes table is seeded with 100-200 entries covering Turkish, North African, Alsatian, Japanese, Italian, Chinese, and French cuisines"
    - "Menus with more than 80 dishes are chunked into batches of 80 for the canonical LLM call"
  artifacts:
    - path: "lib/canonical.ts"
      provides: "generateCanonicalNames() function — batch LLM call, confidence tiers, beverage flagging, chunking"
      contains: "generateCanonicalNames"
    - path: "lib/cache.ts"
      provides: "Canonical name recycling on re-parse + dish_names_hash computation"
      contains: "canonicalCache"
    - path: "app/api/scan/url/route.ts"
      provides: "after() wiring for canonical name generation"
      contains: "generateCanonicalNames"
    - path: "app/api/scan/photo/route.ts"
      provides: "after() wiring for canonical name generation"
      contains: "generateCanonicalNames"
    - path: "supabase/migrations/20260228210000_known_dishes_seed.sql"
      provides: "100-200 seed entries for known_dishes table"
      contains: "INSERT INTO known_dishes"
  key_links:
    - from: "app/api/scan/url/route.ts"
      to: "lib/canonical.ts"
      via: "import generateCanonicalNames, called inside after()"
      pattern: "after.*generateCanonicalNames"
    - from: "app/api/scan/photo/route.ts"
      to: "lib/canonical.ts"
      via: "import generateCanonicalNames, called inside after()"
      pattern: "after.*generateCanonicalNames"
    - from: "lib/canonical.ts"
      to: "supabaseAdmin.from('menu_items')"
      via: "batch upsert of canonical results"
      pattern: "supabaseAdmin.*menu_items.*upsert"
    - from: "lib/cache.ts"
      to: "lib/cache.ts"
      via: "canonicalCache recycling mirrors existing translationCache pattern"
      pattern: "canonicalCache.*canonical_name"
---

<objective>
Wire canonical name generation into the scan pipeline. Every scanned dish receives a normalized canonical name via an async batch LLM call that runs inside after(). Seed the known_dishes table with 100-200 entries for Strasbourg's foreign cuisines. Add canonical name recycling to the re-parse flow so cached names survive URL re-scans. Implement content-aware diff via dish_names_hash.

Purpose: This is the core intelligence of Phase 10 — the canonical name is the keystone for all v1.2 features (deduplication, enrichment, search, recommendations). Without it, no downstream phase can function.

Output: lib/canonical.ts, updated scan routes, updated cache.ts, seed migration.
</objective>

<execution_context>
@/Users/ekitcho/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ekitcho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-db-foundation-canonical-names/10-RESEARCH.md
@.planning/phases/10-db-foundation-canonical-names/10-01-SUMMARY.md
@lib/cache.ts
@lib/google-places.ts
@lib/types/llm.ts
@lib/types/menu.ts
@lib/types/config.ts
@lib/supabase-admin.ts
@lib/openai.ts
@app/api/scan/url/route.ts
@app/api/scan/photo/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/canonical.ts + seed migration + update cache.ts with recycling and hash</name>
  <files>lib/canonical.ts, lib/cache.ts, supabase/migrations/20260228210000_known_dishes_seed.sql</files>
  <action>
**Create `lib/canonical.ts`** — the core canonical name generation module. Follow the exact pattern of `lib/google-places.ts` (fire-and-forget, server-only, never throws):

```typescript
import 'server-only';
import { generateText, Output, NoObjectGeneratedError } from 'ai';
import { openai } from '@ai-sdk/openai';
import { canonicalBatchSchema } from './types/llm';
import { supabaseAdmin } from './supabase-admin';
import { DEFAULT_LLM_MODEL } from './types/config';
import { getAdminConfig } from './cache';
```

**generateCanonicalNames(menuId: string): Promise<void>**

Implementation details:

1. **Fetch pending items**: Query `menu_items` where `menu_id = menuId` AND `canonical_name IS NULL`. Select `id, name_original, category, subcategory`. If no items, return early.

2. **Chunk large menus**: If items.length > 80, split into chunks of 80. Process each chunk sequentially (inside after(), no hurry). This prevents LLM timeout on 200-dish menus (Research Pitfall 2).

3. **Build dish list for LLM**: Map items to `{ index, name, category, subcategory }` objects.

4. **System prompt** — the canonical name normalization prompt. Include these rules:
   - CANONICAL NAME: Standard international name in Latin script. Use the most widely recognized form (e.g., "Mantı" not "Manti" or "Turkish Dumplings", "Tarte Flambée" not "Flammekueche"). Latin diacritics are OK (Mantı, Börek) but no Arabic/CJK/Cyrillic script.
   - CONFIDENCE: 0.0–1.0. High (>=0.80) when certain. Medium (0.50–0.79) when dish matches a known type with variation. Low (<0.50) when ambiguous or guessing.
   - IS_BEVERAGE: true for drinks (water, wine, beer, juice, coffee, tea, soda, cocktail, etc.). false for food AND desserts. Leverage the category/subcategory fields for context.
   - If dish name is already its canonical form (e.g., simple French dishes), return unchanged with high confidence.
   - Desserts are food, not beverages (`is_beverage = false`). Per research recommendation.
   - Return the same `index` as input for merge.

5. **LLM call**: Use `generateText` + `Output.object({ schema: canonicalBatchSchema })` with `maxRetries: 1`. Read model from `getAdminConfig()`.

6. **Process results**: For each result from LLM output:
   - Find matching item by index
   - Determine `enrichment_status` based on confidence and beverage flag:
     - `is_beverage = true` → `enrichment_status = 'pending'` (per KNOW-04: beverages deprioritized but never skipped entirely; is_beverage flag signals Phase 11 to process with lower priority)
     - `confidence >= 0.50 && !is_beverage` → `enrichment_status = 'pending'` (food items queued for Phase 11 enrichment)
     - `confidence < 0.50` → `enrichment_status = 'pending'` (low confidence, needs review)
     - `canonical_name = null` → `enrichment_status = 'failed'`
   - Set `canonical_source = 'llm_generated'`

7. **Batch upsert**: Use `supabaseAdmin.from('menu_items').upsert(updates, { onConflict: 'id' })` — one round-trip per chunk.

8. **Error handling**: Catch all errors. Log with `[generateCanonicalNames]` prefix. NEVER throw — this runs inside `after()`, throwing would crash the background task silently.

**Update `lib/cache.ts`** — add canonical name recycling and dish_names_hash:

1. **Add `hashDishNames` helper** (after existing `hashUrl`):
   ```typescript
   export function hashDishNames(dishes: { name_original: string }[]): string {
     const names = dishes
       .map(d => d.name_original.trim().toLowerCase())
       .sort()
       .join('|');
     return createHash('sha256').update(names).digest('hex');
   }
   ```

2. **In `getOrParseMenu`, expand the harvest block** (Step 5.5, around line 195-218):
   - Add canonical fields to the SELECT query for old items: `name_original, name_translations, description_translations, canonical_name, canonical_confidence, canonical_source, is_beverage, enrichment_status`
   - Build a `canonicalCache` Map alongside the existing `translationCache`:
     ```typescript
     const canonicalCache = new Map<string, {
       canonical_name: string | null;
       canonical_confidence: number | null;
       canonical_source: string | null;
       is_beverage: boolean;
       enrichment_status: string;
     }>();
     ```
   - Populate it from old items: if `old.canonical_name` is not null, store in map keyed by `name_original`.

3. **In the menu_items insert block** (around line 251-281), recycle canonical data:
   - For each dish, look up `canonicalCache.get(dish.name_original)`
   - If found, include the recycled canonical fields in the insert object
   - If not found, leave canonical fields as their column defaults (null / 'pending')

4. **After menu_items insert, compute and store dish_names_hash**:
   - Call `hashDishNames(parsed.dishes)` to get the hash
   - Update the menu row: `supabaseAdmin.from('menus').update({ dish_names_hash: hash }).eq('id', menuRow.id)`
   - This is fire-and-forget (`.then(() => {})`)

5. **Content-aware re-scan optimization** — In the cache check section, BEFORE deleting old menu:
   - If `oldMenu` exists, also fetch its `dish_names_hash` from the menus table
   - Compute the new hash from `parsed.dishes`
   - If hashes match AND old menu has items with canonical names, this means the menu content hasn't changed — but we still need to re-store (cache TTL refresh). The key optimization: set a flag `skipCanonicalGeneration = true` that the caller (scan route) can use to skip the `after()` canonical call.
   - Return this flag in the MenuWithItems return type... Actually, simpler approach: just recycle canonical names via the cache (which we already do) and let `generateCanonicalNames` handle the "nothing to do" case naturally (it queries `WHERE canonical_name IS NULL` — if all items were recycled, query returns 0 rows, function returns early). This is more elegant and requires no flag passing.

**Create `supabase/migrations/20260228210000_known_dishes_seed.sql`** — seed table with 100-200 entries:

Populate `known_dishes` with dishes across these cuisines, prioritizing dishes that are hardest to interpret for non-native diners:

- **Turkish** (~30 entries): Mantı, Lahmacun, Köfte, Döner Kebab, İskender, Mercimek Çorbası, Börek, Pide, Adana Kebab, Beyti, Çiğ Köfte, Hünkâr Beğendi, İmam Bayıldı, Kuzu Tandır, Menemen, Simit, Sucuk, Baklava (Turkish version), Künefe, Gözleme, Karnıyarık, Kısır, Çoban Salatası, Sigara Böreği, Sarma/Dolma, Ezme, Cacık, Acılı Ezme, Iskender Kebab, Dürüm
- **North African** (~20 entries): Couscous, Tajine, Merguez, Pastilla, Harira, Briouate, Chakchouka, Mechouia, Zaalouk, Msemen, Rfissa, Brik, Lablabi, Mloukhia, Makroud, Chorba, Ojja, Kefta, Loubia, Ful Medames
- **Alsatian** (~15 entries): Tarte Flambée, Choucroute, Baeckeoffe, Munster, Presskopf, Fleischnacka, Bibalakas, Kugelhopf, Bredele, Spätzle, Fleischschnacka, Roïgabrageldi, Winstub salad, Bretzel, Streusel
- **Japanese** (~15 entries): Ramen, Gyoza, Takoyaki, Okonomiyaki, Tonkatsu, Tempura, Soba, Udon, Katsudon, Yakitori, Edamame, Miso Soup, Onigiri, Karaage, Chirashi
- **Italian** (~15 entries): Osso Buco, Risotto, Arancini, Burrata, Tiramisu, Saltimbocca, Panna Cotta, Bruschetta, Gnocchi, Polenta, Vitello Tonnato, Ribollita, Caponata, Supplì, Cacio e Pepe
- **Chinese** (~15 entries): Dim Sum, Peking Duck, Mapo Tofu, Baozi, Dan Dan Noodles, Kung Pao Chicken, Char Siu, Wonton Soup, Hot Pot, Xiaolongbao, Congee, Jiaozi, Zongzi, Spring Rolls, Chow Mein
- **French gastronomy** (~15 entries): Pot-au-feu, Blanquette de Veau, Bouillabaisse, Quenelle, Tête de Veau, Andouillette, Cassoulet, Confit de Canard, Rillettes, Navarin, Brandade, Garbure, Piperade, Aligot, Daube Provençale

Each entry should have:
- `canonical_name` — the standard Latin-script name
- `aliases` — TEXT[] with 3-5 variants (common misspellings, transliterations, English/French equivalents)
- `cuisine` — lowercase ('turkish', 'north_african', 'alsatian', 'japanese', 'italian', 'chinese', 'french')
- `is_beverage` — FALSE for all food entries
- `description_fr` — brief cultural description in French (1-2 sentences)
- `description_en` — brief cultural description in English (1-2 sentences)

Use `ON CONFLICT (canonical_name) DO NOTHING` to make the migration idempotent.

The total should be 120-150 entries (quality over quantity — each entry must have meaningful aliases and cultural descriptions).
  </action>
  <verify>
1. `lib/canonical.ts` compiles: `npx tsc --noEmit`
2. Seed SQL is syntactically valid (check for unescaped single quotes in descriptions — use two single quotes `''` to escape)
3. `canonicalCache` recycling logic is present in `lib/cache.ts` alongside `translationCache`
4. `hashDishNames` function is exported from `lib/cache.ts`
5. Seed migration has at least 120 entries across all 7 cuisines
  </verify>
  <done>
`lib/canonical.ts` exists with `generateCanonicalNames()` function. `lib/cache.ts` has canonical recycling + `hashDishNames`. Seed migration has 120+ entries. All code compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire generateCanonicalNames into scan routes via after()</name>
  <files>app/api/scan/url/route.ts, app/api/scan/photo/route.ts</files>
  <action>
**In `app/api/scan/url/route.ts`:**

1. Add import at top:
   ```typescript
   import { generateCanonicalNames } from '@/lib/canonical';
   ```

2. Wire `after()` call for canonical name generation in ALL paths that produce a menu:

   **Path A (eazee-link, cache MISS)** — after `getOrParseMenu` returns (around line 87-89):
   ```typescript
   const menu = await getOrParseMenu(canonicalUrl, 'url', rawText, { ... });
   after(() => enrichWithGooglePlaces(menu.restaurant_name, canonicalUrl, menu.id, placeSearchHint));
   after(async () => { await generateCanonicalNames(menu.id); });
   return NextResponse.json({ menuId: menu.id });
   ```

   **Path A (eazee-link, cache HIT)** — canonical names were already generated on first scan. The existing `after()` for Places backfill is fine. Do NOT add canonical generation here — items already have canonical names from the original scan (or will be recycled from canonicalCache).

   **Path B (generic URL, text)** — after `getOrParseMenu` (around line 97-99):
   ```typescript
   const menu = await getOrParseMenu(url, 'url', result.content);
   after(() => enrichWithGooglePlaces(menu.restaurant_name, url, menu.id));
   after(async () => { await generateCanonicalNames(menu.id); });
   return NextResponse.json({ menuId: menu.id });
   ```

   **Path B2 (PDF)** — after `getOrParseMenu` (around line 130-132):
   ```typescript
   const menu = await getOrParseMenu(url, 'url', '[pdf menu]', output);
   after(() => enrichWithGooglePlaces(menu.restaurant_name, url, menu.id));
   after(async () => { await generateCanonicalNames(menu.id); });
   return NextResponse.json({ menuId: menu.id });
   ```

   **Path C (screenshot fallback)** — after `getOrParseMenu` (around line 162-164):
   ```typescript
   const menu = await getOrParseMenu(url, 'url', '[screenshot fallback]', output);
   after(() => enrichWithGooglePlaces(menu.restaurant_name, url, menu.id));
   after(async () => { await generateCanonicalNames(menu.id); });
   return NextResponse.json({ menuId: menu.id });
   ```

Note: Two separate `after()` calls are valid — they run concurrently. Next.js docs confirm `after` can be called multiple times.

**In `app/api/scan/photo/route.ts`:**

1. Add import at top:
   ```typescript
   import { generateCanonicalNames } from '@/lib/canonical';
   ```

2. Wire `after()` call after `getOrParseMenu` (around line 67-68):
   ```typescript
   const menu = await getOrParseMenu(photoUrl, 'photo', '[photo upload]', output);
   after(() => enrichWithGooglePlaces(menu.restaurant_name, photoUrl, menu.id));
   after(async () => { await generateCanonicalNames(menu.id); });
   return NextResponse.json({ menuId: menu.id });
   ```

IMPORTANT: Do NOT add canonical generation to cache HIT paths. Cache hits return existing data — canonical names were already generated on first scan. The recycling logic in `getOrParseMenu` ensures canonical names survive re-parse.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Both scan routes import `generateCanonicalNames`
3. Every code path that calls `getOrParseMenu` (cache MISS paths) also calls `after(() => generateCanonicalNames(menu.id))`
4. Cache HIT paths do NOT call generateCanonicalNames
5. `after()` calls are separate from enrichWithGooglePlaces (not chained inside the same callback)
  </verify>
  <done>
Both scan routes wire `generateCanonicalNames` inside `after()` on all cache-miss paths. Photo route wired identically. Canonical generation is fully async — scan response time is unaffected. `tsc --noEmit` passes.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `lib/canonical.ts` exports `generateCanonicalNames` function
3. `lib/cache.ts` exports `hashDishNames` function and contains canonicalCache recycling logic
4. Both scan routes import and call `generateCanonicalNames` inside `after()` on cache-miss paths
5. Seed migration has 120+ entries across 7 cuisines with aliases, descriptions, and `ON CONFLICT DO NOTHING`
6. Scanning a Turkish menu (e.g., eazee-link E7FNRP0ET3) would produce canonical_name values in menu_items (verifiable via Supabase dashboard after deployment)
7. Re-scanning the same URL recycles canonical names via canonicalCache — generateCanonicalNames finds 0 rows with `canonical_name IS NULL` and returns early
8. Beverages get `is_beverage=true` and `enrichment_status='pending'` (is_beverage flag signals deprioritization to Phase 11, not skipped)
</verification>

<success_criteria>
- Every scanned dish receives a canonical_name via async LLM generation (KNOW-01)
- known_dishes table is seeded with 120+ entries for Strasbourg cuisines (KNOW-02)
- Canonical generation runs inside after(), never blocking the scan response (KNOW-03)
- Beverages are flagged (is_beverage=true) with enrichment_status='pending' — deprioritized by Phase 11 via the flag, never skipped entirely (KNOW-04)
- Re-scan preserves existing canonical names via recycling (cache pattern)
- Large menus are chunked to prevent LLM timeout
</success_criteria>

<output>
After completion, create `.planning/phases/10-db-foundation-canonical-names/10-02-SUMMARY.md`
</output>
