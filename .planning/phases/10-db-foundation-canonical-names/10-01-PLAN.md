---
phase: 10-db-foundation-canonical-names
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260228200000_v12_foundation.sql
  - lib/types/menu.ts
  - lib/types/llm.ts
autonomous: true
requirements:
  - KNOW-01
  - KNOW-02

must_haves:
  truths:
    - "menu_items table has canonical_name, canonical_confidence, canonical_source, is_beverage, enrichment_status, and embedding columns"
    - "known_dishes table exists with canonical_name (unique), aliases TEXT[], cuisine, is_beverage, description_fr, description_en, embedding columns"
    - "match_dishes RPC function exists and accepts query_embedding, match_threshold, match_count parameters"
    - "HNSW indexes exist on both menu_items.embedding and known_dishes.embedding"
    - "TypeScript MenuItem interface includes all new canonical/enrichment fields"
    - "Menu interface includes dish_names_hash field for content-aware re-scan diff"
  artifacts:
    - path: "supabase/migrations/20260228200000_v12_foundation.sql"
      provides: "pgvector + unaccent extensions, new columns, known_dishes table, HNSW indexes, match_dishes RPC, dish_names_hash on menus"
      contains: "CREATE EXTENSION IF NOT EXISTS vector"
    - path: "lib/types/menu.ts"
      provides: "Updated MenuItem and Menu interfaces with canonical/enrichment fields"
      contains: "canonical_name"
    - path: "lib/types/llm.ts"
      provides: "canonicalBatchSchema Zod schema for LLM structured output"
      contains: "canonicalBatchSchema"
  key_links:
    - from: "supabase/migrations/20260228200000_v12_foundation.sql"
      to: "lib/types/menu.ts"
      via: "TypeScript types mirror DB columns exactly"
      pattern: "canonical_name.*canonical_confidence.*is_beverage.*enrichment_status"
---

<objective>
Create the SQL migration and TypeScript types for the v1.2 dish enrichment foundation.

Purpose: Every subsequent Phase 10-14 feature depends on these schema additions. The migration enables pgvector (vector similarity search), unaccent (accent-insensitive matching), adds canonical name + enrichment columns to menu_items, creates the known_dishes seed table, and provisions the match_dishes RPC. TypeScript types are updated to mirror the new DB shape.

Output: One SQL migration file, updated TypeScript types, and the Zod schema for canonical name batch LLM output.
</objective>

<execution_context>
@/Users/ekitcho/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ekitcho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-db-foundation-canonical-names/10-RESEARCH.md
@lib/types/menu.ts
@lib/types/llm.ts
@supabase/migrations/20260228150000_google_places_columns.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQL migration — pgvector, unaccent, new columns, known_dishes table, indexes, RPC</name>
  <files>supabase/migrations/20260228200000_v12_foundation.sql</files>
  <action>
Create a single SQL migration file that does the following in order:

1. **Enable extensions** (must use `WITH SCHEMA extensions`):
   ```sql
   CREATE EXTENSION IF NOT EXISTS vector WITH SCHEMA extensions;
   CREATE EXTENSION IF NOT EXISTS unaccent WITH SCHEMA extensions;
   ```

2. **Add columns to menu_items** (all nullable or with defaults — safe for existing rows):
   - `canonical_name TEXT` — normalized dish name in Latin script
   - `canonical_confidence FLOAT` — 0.0 to 1.0 confidence score
   - `canonical_source TEXT` — 'seed_match' | 'llm_generated'
   - `is_beverage BOOLEAN NOT NULL DEFAULT FALSE`
   - `enrichment_status TEXT NOT NULL DEFAULT 'pending'` — one of: 'pending', 'enriched', 'skipped', 'failed'
   - `embedding extensions.vector(1536)` — for semantic search (Phase 14)
   - `embedding_model TEXT` — stores which model generated the embedding (per STATE.md decision: store from day one, locked to text-embedding-3-small for v1.2)

3. **Add dish_names_hash column to menus table** — for content-aware re-scan diff:
   - `dish_names_hash TEXT` — SHA-256 of sorted dish names, used to detect if menu content changed on re-scan

4. **Create HNSW index on menu_items.embedding**:
   ```sql
   CREATE INDEX IF NOT EXISTS idx_menu_items_embedding
     ON menu_items USING hnsw (embedding extensions.vector_cosine_ops);
   ```

5. **Create partial index on enrichment_status** for efficient queue polling:
   ```sql
   CREATE INDEX IF NOT EXISTS idx_menu_items_enrichment_pending
     ON menu_items (enrichment_status)
     WHERE enrichment_status = 'pending';
   ```

6. **Create known_dishes table**:
   ```sql
   CREATE TABLE IF NOT EXISTS known_dishes (
     id               UUID        PRIMARY KEY DEFAULT gen_random_uuid(),
     canonical_name   TEXT        NOT NULL UNIQUE,
     aliases          TEXT[]      NOT NULL DEFAULT '{}',
     cuisine          TEXT,
     is_beverage      BOOLEAN     NOT NULL DEFAULT FALSE,
     description_fr   TEXT,
     description_en   TEXT,
     embedding        extensions.vector(1536),
     embedding_model  TEXT,
     created_at       TIMESTAMPTZ DEFAULT NOW()
   );
   ```

7. **Create HNSW index on known_dishes.embedding**:
   ```sql
   CREATE INDEX IF NOT EXISTS idx_known_dishes_embedding
     ON known_dishes USING hnsw (embedding extensions.vector_cosine_ops);
   ```

8. **Create match_dishes RPC** — semantic similarity search function (infrastructure for Phase 14, not called in Phase 10):
   ```sql
   CREATE OR REPLACE FUNCTION match_dishes(
     query_embedding  extensions.vector(1536),
     match_threshold  FLOAT    DEFAULT 0.85,
     match_count      INT      DEFAULT 5
   )
   RETURNS TABLE (
     id              UUID,
     canonical_name  TEXT,
     aliases         TEXT[],
     cuisine         TEXT,
     similarity      FLOAT
   )
   LANGUAGE sql STABLE AS $$
     SELECT
       id,
       canonical_name,
       aliases,
       cuisine,
       1 - (embedding <=> query_embedding) AS similarity
     FROM known_dishes
     WHERE 1 - (embedding <=> query_embedding) > match_threshold
     ORDER BY embedding <=> query_embedding
     LIMIT match_count;
   $$;
   ```

Use `IF NOT EXISTS` / `IF NOT EXISTS` guards on all CREATE statements. Use `ADD COLUMN IF NOT EXISTS` for all ALTER TABLE statements. This makes the migration idempotent.

IMPORTANT: Use `extensions.vector(1536)` (not just `vector(1536)`) — Supabase installs pgvector in the `extensions` schema by default. Mismatched references cause "type vector does not exist" errors (Research Pitfall 3).
  </action>
  <verify>
Run `npx supabase db push --dry-run` (if Supabase CLI is available) or visually inspect the SQL for syntax correctness. Verify:
- All `vector` references are `extensions.vector(1536)`
- Both extensions enabled with `WITH SCHEMA extensions`
- All ALTER TABLE uses `IF NOT EXISTS`
- known_dishes has UNIQUE constraint on canonical_name
- match_dishes function signature matches the expected return type
  </verify>
  <done>
Migration file exists at `supabase/migrations/20260228200000_v12_foundation.sql` with pgvector, unaccent, all new columns on menu_items, dish_names_hash on menus, known_dishes table, both HNSW indexes, partial enrichment_status index, and match_dishes RPC function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update TypeScript types + add canonical Zod schema</name>
  <files>lib/types/menu.ts, lib/types/llm.ts</files>
  <action>
**In `lib/types/menu.ts`:**

1. Add new fields to the `MenuItem` interface, after `sort_order`:
   ```typescript
   canonical_name: string | null;
   canonical_confidence: number | null;
   canonical_source: string | null;   // 'seed_match' | 'llm_generated'
   is_beverage: boolean;
   enrichment_status: string;         // 'pending' | 'enriched' | 'skipped' | 'failed'
   embedding_model: string | null;
   ```
   Note: `embedding` column is NOT included in the TS type — vectors are DB-only, never fetched by the app (too large for JSON transport).

2. Add `dish_names_hash` to the `Menu` interface, after `hit_count`:
   ```typescript
   dish_names_hash: string | null;    // SHA-256 of sorted dish names for re-scan diff
   ```

**In `lib/types/llm.ts`:**

3. Add the canonical batch Zod schema (for Phase 10 Plan 02 LLM call). Add AFTER the existing eazee-link schemas, BEFORE the type inference section:

   ```typescript
   // =============================================================================
   // Canonical name batch schema — LLM output for batch canonical name generation
   // =============================================================================

   /**
    * Schema for a single dish's canonical name result from the batch LLM call.
    * Index matches the input array position for merging results back.
    */
   export const canonicalDishResultSchema = z.object({
     index: z.number(),
     canonical_name: z.string().nullable(),    // null if LLM cannot determine
     confidence: z.number(),                    // 0.0–1.0
     is_beverage: z.boolean(),
   });

   /**
    * Top-level batch schema — wraps array of canonical results.
    * Passed to AI SDK Output.object() in generateCanonicalNames.
    */
   export const canonicalBatchSchema = z.object({
     dishes: z.array(canonicalDishResultSchema),
   });
   ```

4. Add inferred types at the bottom alongside existing type exports:
   ```typescript
   export type CanonicalDishResult = z.infer<typeof canonicalDishResultSchema>;
   export type CanonicalBatchResult = z.infer<typeof canonicalBatchSchema>;
   ```

IMPORTANT: Use `.nullable()` not `.optional()` on the canonical_name field — OpenAI structured outputs require all properties to be present (established pattern, see file header comment).
  </action>
  <verify>
Run `npx tsc --noEmit` from project root. Verify zero type errors. Confirm:
- MenuItem now has canonical_name, canonical_confidence, canonical_source, is_beverage, enrichment_status, embedding_model
- Menu now has dish_names_hash
- canonicalBatchSchema exports from lib/types/llm.ts
- CanonicalDishResult and CanonicalBatchResult types export correctly
  </verify>
  <done>
TypeScript types mirror the new DB schema exactly. MenuItem has all 6 new fields (canonical_name, canonical_confidence, canonical_source, is_beverage, enrichment_status, embedding_model). Menu has dish_names_hash. Zod canonicalBatchSchema is ready for Plan 02's LLM call. `tsc --noEmit` passes.
  </done>
</task>

</tasks>

<verification>
1. SQL migration file is syntactically valid (no unqualified `vector` references)
2. `npx tsc --noEmit` passes with zero errors
3. MenuItem interface has: canonical_name, canonical_confidence, canonical_source, is_beverage, enrichment_status, embedding_model
4. Menu interface has: dish_names_hash
5. canonicalBatchSchema and canonicalDishResultSchema export from lib/types/llm.ts
6. known_dishes table has UNIQUE on canonical_name and HNSW index on embedding
7. match_dishes RPC function signature returns (id, canonical_name, aliases, cuisine, similarity)
</verification>

<success_criteria>
- Migration file creates the complete v1.2 schema foundation in a single atomic migration
- TypeScript types are in sync with DB schema — no mismatches
- Zod schema for canonical batch LLM output is ready for Plan 02
- No type errors in the project after changes
</success_criteria>

<output>
After completion, create `.planning/phases/10-db-foundation-canonical-names/10-01-SUMMARY.md`
</output>
