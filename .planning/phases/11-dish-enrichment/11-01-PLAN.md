---
phase: 11-dish-enrichment
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260228220000_enrichment_fields.sql
  - lib/types/llm.ts
  - lib/types/menu.ts
  - lib/enrichment.ts
  - app/api/scan/url/route.ts
  - app/api/scan/photo/route.ts
  - app/api/enrichment/status/route.ts
autonomous: true
requirements: [ENRI-01, ENRI-02, ENRI-04]

must_haves:
  truths:
    - "After scanning a menu, food dishes receive enrichment_status='enriched' with cultural context fields populated in the DB within 10 seconds"
    - "Beverages receive enrichment_status='skipped' — never sent to the LLM for enrichment"
    - "Exotic dishes (Mantı, Börek) receive depth_tier='full' with origin, cultural_note, eating_tips; common dishes (steak frites) receive depth_tier='minimal' with ingredients only"
    - "GET /api/enrichment/status?menuId=X returns per-item enrichment status and enrichment data for food items"
  artifacts:
    - path: "supabase/migrations/20260228220000_enrichment_fields.sql"
      provides: "Enrichment columns on menu_items"
      contains: "enrichment_origin"
    - path: "lib/enrichment.ts"
      provides: "Batch LLM enrichment function"
      exports: ["enrichDishBatch"]
    - path: "lib/types/llm.ts"
      provides: "Enrichment Zod schema"
      contains: "enrichmentBatchSchema"
    - path: "app/api/enrichment/status/route.ts"
      provides: "Status polling endpoint"
      exports: ["GET"]
  key_links:
    - from: "app/api/scan/url/route.ts"
      to: "lib/enrichment.ts"
      via: "after() callback chained after generateCanonicalNames"
      pattern: "await enrichDishBatch"
    - from: "lib/enrichment.ts"
      to: "lib/types/llm.ts"
      via: "Zod schema for LLM structured output"
      pattern: "enrichmentBatchSchema"
    - from: "app/api/enrichment/status/route.ts"
      to: "supabase menu_items"
      via: "anon client read"
      pattern: "enrichment_status.*enrichment_origin"
---

<objective>
Build the enrichment backend pipeline: SQL migration for enrichment columns, batch LLM enrichment function with adaptive depth (exotic vs common dishes), scan route wiring via after() chained after canonical names, and a status polling endpoint for the client.

Purpose: Enable async cultural enrichment of food dishes immediately after scanning, providing the data layer and API surface that the UI (Plan 02) will consume.
Output: lib/enrichment.ts, enrichment Zod schema, SQL migration, status polling endpoint, scan routes updated with enrichment wiring.
</objective>

<execution_context>
@/Users/ekitcho/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ekitcho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-dish-enrichment/11-CONTEXT.md
@.planning/phases/11-dish-enrichment/11-RESEARCH.md
@.planning/phases/10-db-foundation-canonical-names/10-02-SUMMARY.md
@lib/canonical.ts
@lib/types/llm.ts
@lib/types/menu.ts
@app/api/scan/url/route.ts
@app/api/scan/photo/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQL migration + Zod schema + MenuItem type additions</name>
  <files>
    supabase/migrations/20260228220000_enrichment_fields.sql
    lib/types/llm.ts
    lib/types/menu.ts
  </files>
  <action>
**SQL migration** — create `supabase/migrations/20260228220000_enrichment_fields.sql`:

Add 7 new columns to `menu_items` using `ADD COLUMN IF NOT EXISTS` (idempotent):
- `enrichment_origin TEXT` — geographic/cultural origin (e.g. "Anatolie centrale, Turquie")
- `enrichment_ingredients TEXT[]` — 3-6 key ingredients in French
- `enrichment_cultural_note TEXT` — cultural/historical context paragraph (full depth only)
- `enrichment_eating_tips TEXT` — how to eat it / what to expect (full depth only)
- `enrichment_depth TEXT` — 'full' | 'minimal' — the LLM's depth tier assignment
- `enrichment_model TEXT` — which model generated the enrichment (for regen tracking)
- `enriched_at TIMESTAMPTZ` — when enrichment was last generated

All columns nullable (safe for existing rows). No indexes needed beyond the existing `idx_menu_items_enrichment_pending` partial index from Phase 10.

NOTE on TEXT[] for ingredients: PostgREST serializes TEXT[] as JSON arrays by default. If issues arise, see Research Pitfall 4. The project already uses TEXT[] for dietary_tags/allergens successfully.

**Zod schema** — add to `lib/types/llm.ts` after the canonical batch schema section:

```typescript
// Enrichment batch schema — LLM output for batch cultural enrichment
export const enrichmentDishResultSchema = z.object({
  index: z.number(),
  depth_tier: z.enum(['full', 'minimal']),
  origin: z.string().nullable(),           // null for minimal depth
  typical_ingredients: z.array(z.string()), // always present, 3-6 items in French
  cultural_note: z.string().nullable(),     // null for minimal depth
  eating_tips: z.string().nullable(),       // null for minimal depth
});

export const enrichmentBatchSchema = z.object({
  dishes: z.array(enrichmentDishResultSchema),
});

export type EnrichmentDishResult = z.infer<typeof enrichmentDishResultSchema>;
export type EnrichmentBatchResult = z.infer<typeof enrichmentBatchSchema>;
```

Uses `.nullable()` (not `.optional()`) per OpenAI structured output requirement (established codebase convention).

**MenuItem type** — add to `lib/types/menu.ts` MenuItem interface, after `enrichment_status`:
```typescript
enrichment_origin: string | null;
enrichment_ingredients: string[] | null;
enrichment_cultural_note: string | null;
enrichment_eating_tips: string | null;
enrichment_depth: string | null;        // 'full' | 'minimal'
enrichment_model: string | null;
enriched_at: string | null;             // ISO string
```
  </action>
  <verify>
Run `npx tsc --noEmit` — zero type errors. Verify the migration file exists and has all 7 ALTER TABLE statements with IF NOT EXISTS guards. Verify `enrichmentBatchSchema` is exported from llm.ts. Verify MenuItem interface has all 7 new fields.
  </verify>
  <done>
SQL migration adds 7 enrichment columns to menu_items. Zod schema validates LLM enrichment output with adaptive depth_tier. MenuItem TypeScript interface includes all enrichment fields. `tsc --noEmit` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: lib/enrichment.ts + scan route wiring + status endpoint</name>
  <files>
    lib/enrichment.ts
    app/api/scan/url/route.ts
    app/api/scan/photo/route.ts
    app/api/enrichment/status/route.ts
  </files>
  <action>
**lib/enrichment.ts** — create new file mirroring `lib/canonical.ts` fire-and-forget pattern exactly:

1. `import 'server-only'` at top
2. Import `generateText`, `Output` from 'ai', `openai` from '@ai-sdk/openai', `enrichmentBatchSchema` from './types/llm', `supabaseAdmin` from './supabase-admin', `getAdminConfig` from './cache'
3. Define `ENRICHMENT_SYSTEM_PROMPT` constant — adaptive depth prompt:
   - Role: culinary cultural educator helping French diners understand unfamiliar dishes
   - Depth assignment rules: `depth_tier = "full"` for foreign/exotic/regional dishes (Mantı, Lahmacun, Börek, Tarte Flambée, Baeckeoffe, Okonomiyaki, Couscous, Mapo Tofu); `depth_tier = "minimal"` for self-explanatory French dishes (steak frites, salade césar, croque-monsieur, poulet rôti, pâtes bolognaise, pizza)
   - Full depth fields: origin (geographic/cultural, concise), typical_ingredients (array, 3-6 items in French), cultural_note (1-2 sentences cultural/historical context in French), eating_tips (1 sentence in French on how to eat it)
   - Minimal depth fields: origin=null, typical_ingredients (3-5 items in French), cultural_note=null, eating_tips=null
   - All text in French. Use canonical_name if provided. Return ALL input dishes with same index.
4. Reuse the `chunk<T>` helper from canonical.ts (or extract to a shared util — Claude's discretion; inline is fine since it's 5 lines)
5. Export `async function enrichDishBatch(menuId: string): Promise<void>`:
   - Step 1: Fetch items with `enrichment_status = 'pending'` from `menu_items` WHERE `menu_id = menuId`. Select: `id, canonical_name, name_original, is_beverage, category, subcategory`. Return early if no items or error.
   - Step 2: Mark beverages as `'skipped'` immediately — `supabaseAdmin.from('menu_items').upsert(beverages.map(b => ({ id: b.id, enrichment_status: 'skipped' })), { onConflict: 'id' })`. This is CRITICAL — if beverages stay 'pending', the polling hook never resolves (Research Pitfall 2).
   - Step 3: Filter to food items only (`!is_beverage`). Return early if none.
   - Step 4: Read admin config for model. Chunk food items at `CHUNK_SIZE = 40` (not 80 — enrichment output is longer than canonical names).
   - Step 5: For each chunk, build `dishList` with `{ index, name, canonical_name, category, subcategory }`. Call `generateText` with `Output.object({ schema: enrichmentBatchSchema })`, `system: ENRICHMENT_SYSTEM_PROMPT`, user message with JSON.stringify({ dishes: dishList }), `maxRetries: 1`.
   - Step 6: Process results — for each result, find matching item by index. Build upsert payload: `{ id, enrichment_origin: result.origin, enrichment_ingredients: result.typical_ingredients, enrichment_cultural_note: result.cultural_note, enrichment_eating_tips: result.eating_tips, enrichment_depth: result.depth_tier, enrichment_model: config.llm_model, enrichment_status: 'enriched', enriched_at: new Date().toISOString() }`.
   - Step 7: Upsert with `supabaseAdmin.from('menu_items').upsert(updates, { onConflict: 'id' })`.
   - Step 8: Items not returned by LLM — mark as `enrichment_status: 'failed'` (same pattern as canonical.ts).
   - Error handling: per-batch try/catch (continue on failure), top-level try/catch (never throw). Log with `[enrichDishBatch]` prefix.

**Scan route wiring** — update BOTH `app/api/scan/url/route.ts` and `app/api/scan/photo/route.ts`:

1. Add import: `import { enrichDishBatch } from '@/lib/enrichment';`
2. CRITICAL: Change the existing `after(async () => { await generateCanonicalNames(menu.id); })` calls to chain enrichment sequentially:
```typescript
after(async () => {
  await generateCanonicalNames(menu.id);
  await enrichDishBatch(menu.id);
});
```
This ensures `is_beverage` is set by canonical generation before enrichment reads it (Research Pitfall 1). Do NOT add enrichment as a third concurrent `after()` call.

In `url/route.ts`, update ALL 4 cache-miss paths (eazee-link miss, generic text, PDF, screenshot fallback). Cache HIT path (line 80 return) intentionally skipped — enrichment status preserved from original scan.

In `photo/route.ts`, update the single `after()` call for canonical names.

**Status polling endpoint** — create `app/api/enrichment/status/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';  // anon client — NOT supabaseAdmin (Research: status endpoint is public, no PII)

export async function GET(req: NextRequest) {
  const menuId = req.nextUrl.searchParams.get('menuId');
  if (!menuId) return NextResponse.json({ error: 'Missing menuId' }, { status: 400 });

  const { data, error } = await supabase
    .from('menu_items')
    .select('id, enrichment_status, enrichment_origin, enrichment_ingredients, enrichment_cultural_note, enrichment_eating_tips, enrichment_depth')
    .eq('menu_id', menuId)
    .eq('is_beverage', false);  // food items only — beverages are irrelevant to the UI

  if (error) return NextResponse.json({ error: error.message }, { status: 500 });
  return NextResponse.json({ items: data });
}
```

Use the anon Supabase client (`lib/supabase.ts`), NOT `supabaseAdmin`. Enrichment fields contain no PII. Filter `is_beverage = false` to return only food items (beverages are 'skipped' and don't need polling).
  </action>
  <verify>
Run `npx tsc --noEmit` — zero type errors. Verify `lib/enrichment.ts` exports `enrichDishBatch`. Verify both scan routes import `enrichDishBatch` and chain it after `generateCanonicalNames` in the same `after()` callback. Verify `app/api/enrichment/status/route.ts` exports `GET` and uses the anon client. Grep for any remaining standalone `after(async () => { await generateCanonicalNames` calls — should be zero (all should now chain enrichment).
  </verify>
  <done>
`enrichDishBatch` generates adaptive-depth cultural enrichment for food dishes via batch LLM call, marks beverages as 'skipped', and is chained after canonical name generation in both scan routes. Status polling endpoint returns enrichment data for food items via anon client. `tsc --noEmit` passes.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. SQL migration has 7 `ALTER TABLE ... ADD COLUMN IF NOT EXISTS` statements
3. `enrichmentBatchSchema` exported from `lib/types/llm.ts` with `depth_tier`, `origin`, `typical_ingredients`, `cultural_note`, `eating_tips`
4. `enrichDishBatch` exported from `lib/enrichment.ts`, marks beverages as 'skipped', chunks food at 40
5. Both scan routes chain `enrichDishBatch` after `generateCanonicalNames` in the same `after()` — no concurrent race
6. `GET /api/enrichment/status` uses anon client, filters `is_beverage = false`
</verification>

<success_criteria>
- Scanning a menu triggers enrichment via after() after canonical names complete
- Food dishes get cultural enrichment (full or minimal depth based on exoticism)
- Beverages get enrichment_status='skipped' without LLM call
- Status endpoint returns enrichment data for progressive UI polling
- All code compiles with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-dish-enrichment/11-01-SUMMARY.md`
</output>
