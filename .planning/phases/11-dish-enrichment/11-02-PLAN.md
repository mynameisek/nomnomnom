---
phase: 11-dish-enrichment
plan: "02"
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - hooks/useEnrichmentPolling.ts
  - components/menu/DishCard.tsx
  - components/menu/DishDetailSheet.tsx
  - components/menu/MenuShell.tsx
  - app/actions/enrichment.ts
  - components/admin/AdminDashboard.tsx
autonomous: true
requirements: [ENRI-01, ENRI-03, ENRI-04]

must_haves:
  truths:
    - "While enrichment is pending, each food DishCard shows a subtle skeleton shimmer line"
    - "Once enriched, a full-depth DishCard shows an origin pill and truncated cultural hint — tapping opens a bottom sheet with full detail"
    - "Once enriched, a minimal-depth DishCard shows key ingredients inline — no cultural hint or bottom sheet trigger"
    - "Tapping Régénérer per dish in the admin panel re-enriches that dish and replaces its stored enrichment"
    - "Tapping Ré-enrichir tout per menu in the admin panel re-enriches all food dishes in that menu"
    - "Enrichment data appears progressively on DishCards without page reload"
  artifacts:
    - path: "hooks/useEnrichmentPolling.ts"
      provides: "Client-side polling hook for enrichment status"
      exports: ["useEnrichmentPolling"]
    - path: "components/menu/DishDetailSheet.tsx"
      provides: "Bottom sheet detail view for full enrichment"
    - path: "app/actions/enrichment.ts"
      provides: "Admin regeneration Server Actions"
      exports: ["regenerateDishEnrichment", "regenerateMenuEnrichment"]
  key_links:
    - from: "components/menu/MenuShell.tsx"
      to: "hooks/useEnrichmentPolling.ts"
      via: "hook call in MenuShellInner"
      pattern: "useEnrichmentPolling"
    - from: "components/menu/DishCard.tsx"
      to: "components/menu/DishDetailSheet.tsx"
      via: "state-driven sheet open on tap"
      pattern: "setDetailDish"
    - from: "components/admin/AdminDashboard.tsx"
      to: "app/actions/enrichment.ts"
      via: "Server Action calls for regen"
      pattern: "regenerateDishEnrichment|regenerateMenuEnrichment"
---

<objective>
Build the progressive DishCard UI with enrichment preview, bottom sheet detail view, client-side polling for real-time updates, and admin regeneration actions.

Purpose: Make enrichment visible to users (progressive disclosure: loading shimmer -> light preview -> full detail on tap) and give admins the ability to regenerate enrichment data.
Output: Polling hook, enhanced DishCard, DishDetailSheet bottom sheet, admin regen Server Actions, updated AdminDashboard.
</objective>

<execution_context>
@/Users/ekitcho/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ekitcho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-dish-enrichment/11-CONTEXT.md
@.planning/phases/11-dish-enrichment/11-RESEARCH.md
@.planning/phases/11-dish-enrichment/11-01-SUMMARY.md
@components/menu/DishCard.tsx
@components/menu/MenuShell.tsx
@components/admin/AdminDashboard.tsx
@lib/types/menu.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-modal-sheet + polling hook + DishDetailSheet + DishCard enhancement</name>
  <files>
    hooks/useEnrichmentPolling.ts
    components/menu/DishDetailSheet.tsx
    components/menu/DishCard.tsx
    components/menu/MenuShell.tsx
  </files>
  <action>
**Install dependency:**
```bash
npm install react-modal-sheet
```
`react-modal-sheet@5.2.1` requires `motion>=11` — already installed (`motion@^12.34.3`). Zero new transitive dependencies.

**hooks/useEnrichmentPolling.ts** — create new file:

```typescript
'use client';
import { useEffect, useRef, useState, useCallback } from 'react';
import type { MenuItem } from '@/lib/types/menu';

const POLL_INTERVAL_MS = 3000;

export function useEnrichmentPolling(menuId: string, initialItems: MenuItem[]) {
  const [enrichedItems, setEnrichedItems] = useState(initialItems);
  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const mountedRef = useRef(true);

  const hasPendingFoodItems = useCallback((itemList: MenuItem[]) =>
    itemList.some(i => !i.is_beverage && i.enrichment_status === 'pending'),
  []);

  useEffect(() => {
    mountedRef.current = true;
    if (!hasPendingFoodItems(initialItems)) return;

    const poll = async () => {
      try {
        const res = await fetch(`/api/enrichment/status?menuId=${menuId}`);
        if (!res.ok || !mountedRef.current) return;
        const data = await res.json();
        if (!data.items || !mountedRef.current) return;

        setEnrichedItems(prev =>
          prev.map(item => {
            const fresh = data.items.find((d: { id: string }) => d.id === item.id);
            return fresh ? { ...item, ...fresh } : item;
          })
        );

        // Stop polling when no food items are still pending
        const stillPending = data.items.some(
          (d: { enrichment_status: string }) => d.enrichment_status === 'pending'
        );
        if (!stillPending && intervalRef.current) {
          clearInterval(intervalRef.current);
          intervalRef.current = null;
        }
      } catch (err) {
        console.error('[useEnrichmentPolling] Poll error:', err);
      }
    };

    intervalRef.current = setInterval(poll, POLL_INTERVAL_MS);

    return () => {
      mountedRef.current = false;
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, [menuId, hasPendingFoodItems, initialItems]);

  return enrichedItems;
}
```

The hook polls every 3s until all food items have `enrichment_status !== 'pending'`, then stops. Returns the progressively updated items array. Cleanup on unmount prevents memory leaks.

**components/menu/DishDetailSheet.tsx** — create new file:

Mobile-native bottom sheet using `react-modal-sheet` compound API. Opens when user taps a full-depth enriched dish.

Structure:
- `Sheet` with `isOpen`, `onClose`, `detent="content-height"`
- `Sheet.Container` with `className="!bg-brand-bg border-t border-white/10"` (the `!` ensures override through the portal; verify Tailwind v4 `:root` brand variables propagate to portal)
- `Sheet.Header` — default drag handle, styled with `!bg-brand-bg`
- `Sheet.Content` — scrollable content area
- Content layout:
  1. Dish name (canonical_name ?? name_original) as h2 (`text-brand-white font-bold text-lg`)
  2. Origin line below name (`text-brand-orange/70 text-sm`)
  3. Cultural note paragraph (`text-brand-muted text-sm leading-relaxed`)
  4. "Ingrédients typiques" section header (`text-brand-white/60 text-xs uppercase tracking-wider`) + ingredient chips in flex-wrap (`px-2 py-0.5 rounded-full bg-white/5 border border-white/10 text-brand-muted text-xs`)
  5. Eating tips as italic muted text (`text-brand-muted/70 text-xs italic`)
- `Sheet.Backdrop` with `onTap={onClose}`

Props: `{ item: MenuItem | null; isOpen: boolean; onClose: () => void }`. Render null-safe (item can be null when sheet is closed).

**components/menu/DishCard.tsx** — enhance existing component:

Add three enrichment states below the description, before the bottom row (trust badge + dietary tags):

1. **Pending skeleton** (while `enrichment_status === 'pending' && !is_beverage`):
   - Single line skeleton shimmer: `<div className="h-3 w-3/4 rounded-full bg-white/10 animate-pulse mt-1" />`
   - Minimal footprint — just one line, no text

2. **Full-depth preview** (when `enrichment_status === 'enriched' && enrichment_depth === 'full'`):
   - Tappable row: origin pill + truncated cultural note
   - Origin pill: `<span className="flex-shrink-0 px-1.5 py-0.5 rounded-full bg-brand-orange/10 border border-brand-orange/20 text-brand-orange/70 text-[10px] font-medium">{item.enrichment_origin.split(',')[0].trim()}</span>`
   - Cultural hint: first ~60 chars of `enrichment_cultural_note` + "..." truncated (`text-brand-muted/70 text-xs truncate`)
   - The entire row is a `<button>` that calls `onTapDetail(item)` — a new callback prop

3. **Minimal-depth preview** (when `enrichment_status === 'enriched' && enrichment_depth === 'minimal'`):
   - Show first 3 ingredients inline: `<p className="text-brand-muted/60 text-xs mt-1">{item.enrichment_ingredients?.slice(0, 3).join(', ')}</p>`
   - No tap interaction — dish is self-explanatory, no detail sheet needed

Add new optional prop: `onTapDetail?: (item: MenuItem) => void` — called when user taps the full-depth preview row. If not provided, the preview is non-interactive (graceful degradation).

**components/menu/MenuShell.tsx** — integrate polling + detail sheet:

1. Import `useEnrichmentPolling` from `@/hooks/useEnrichmentPolling`
2. Import `DishDetailSheet` from `@/components/menu/DishDetailSheet`
3. In `MenuShellInner`, add:
   - Call `useEnrichmentPolling(initialMenu.id, initialMenu.menu_items)` to get progressively enriched items
   - Replace the `menuData.menu_items` usage with the enriched items from the polling hook
   - IMPORTANT: The polling hook must work alongside the existing translation state. When translations update `menuData.menu_items` via `setMenuData`, the enrichment fields from polling should merge. Strategy: use the polling hook's returned items as the base, but let translation updates override name/description translations. The simplest approach: pass `menuData.menu_items` (which includes translation updates) to the polling hook as `initialItems` — the hook merges enrichment fields on top.
4. Add state for the detail sheet: `const [detailDish, setDetailDish] = useState<MenuItem | null>(null)`
5. Pass `onTapDetail={setDetailDish}` to `DishCard` in both filtered and accordion render paths (need to update `MenuAccordion` to pass this prop through, OR lift the detail sheet state to `MenuContent` level and pass `onTapDetail` down)
6. Render `<DishDetailSheet item={detailDish} isOpen={!!detailDish} onClose={() => setDetailDish(null)} />` at the bottom of `MenuContent`, OUTSIDE the content area — the sheet uses a portal so placement doesn't affect layout

**MenuAccordion** — update to accept and pass through `onTapDetail` prop. Read the current MenuAccordion component to understand its structure, then add `onTapDetail?: (item: MenuItem) => void` to its props and pass it through to each `DishCard`.
  </action>
  <verify>
Run `npx tsc --noEmit` — zero type errors. Verify `react-modal-sheet` is in `package.json` dependencies. Verify `useEnrichmentPolling` is imported and called in `MenuShellInner`. Verify `DishDetailSheet` is rendered in `MenuContent`. Verify `DishCard` has all three enrichment states (pending shimmer, full preview, minimal preview). Open the app and confirm no build errors.
  </verify>
  <done>
DishCards show skeleton shimmer while pending, origin pill + cultural hint for full-depth dishes (tappable to open bottom sheet), and inline ingredients for minimal-depth dishes. Polling hook updates DishCards progressively without page reload. Bottom sheet displays full enrichment detail. All code compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Admin regeneration Server Actions + AdminDashboard integration</name>
  <files>
    app/actions/enrichment.ts
    components/admin/AdminDashboard.tsx
  </files>
  <action>
**app/actions/enrichment.ts** — create new file with two Server Actions:

```typescript
'use server';
import { isAdminAuthenticated } from '@/lib/admin-session';
import { supabaseAdmin } from '@/lib/supabase-admin';
import { enrichDishBatch } from '@/lib/enrichment';
```

1. `regenerateDishEnrichment(dishId: string): Promise<{ ok: true } | { error: string }>`:
   - Auth guard: `if (!await isAdminAuthenticated()) return { error: 'Unauthorized' }`
   - Fetch `menu_id` from the dish: `supabaseAdmin.from('menu_items').select('menu_id').eq('id', dishId).single()`
   - Return `{ error: 'Dish not found' }` if not found
   - Reset enrichment fields: update the dish with `{ enrichment_status: 'pending', enrichment_origin: null, enrichment_ingredients: null, enrichment_cultural_note: null, enrichment_eating_tips: null, enrichment_depth: null, enrichment_model: null, enriched_at: null }`
   - Call `await enrichDishBatch(item.menu_id)` — synchronous (admin regen does not use `after()`, feedback is immediate per Research recommendation)
   - Return `{ ok: true }`

2. `regenerateMenuEnrichment(menuId: string): Promise<{ ok: true; count: number } | { error: string }>`:
   - Auth guard same as above
   - Reset ALL food items for this menu: `supabaseAdmin.from('menu_items').update({ enrichment_status: 'pending', enrichment_origin: null, enrichment_ingredients: null, enrichment_cultural_note: null, enrichment_eating_tips: null, enrichment_depth: null, enrichment_model: null, enriched_at: null }).eq('menu_id', menuId).eq('is_beverage', false).select('id')`
   - Call `await enrichDishBatch(menuId)` synchronously
   - Return `{ ok: true, count: data?.length ?? 0 }`

NOTE: Per Research Pitfall 5, Server Actions have 60s timeout on Vercel Pro. For Phase 11, this is acceptable — add a count check: if more than 80 food items, return `{ error: 'Menu too large for synchronous regen — max 80 food items' }` before starting.

**components/admin/AdminDashboard.tsx** — add enrichment section:

Read the existing AdminDashboard component first to understand current structure (stat cards, model selector, recent scans table).

Add an enrichment section to the admin dashboard:

1. In the recent scans table, add a new column "Enrichment" showing:
   - Per-menu: a "Ré-enrichir tout" button that calls `regenerateMenuEnrichment(menuId)`
   - Use `useTransition()` for isPending state — button shows "En cours..." while the Server Action runs, disabled during execution

2. Add enrichment stats to the dashboard (if scan data includes enrichment info):
   - Count of menus with pending enrichment vs completed

3. Per-dish regen is admin-level but does NOT need to be in the main dashboard table (it's per-dish, not per-menu). The per-dish regen button should be accessible when viewing an individual menu's items in the admin panel. If the admin panel currently shows individual dishes in a drill-down view, add the "Régénérer" button there. If not, add a simple expandable row in the scans table that shows the menu's food items with per-dish regen buttons.

4. UX details (Claude's Discretion):
   - No modal confirmation for per-dish regen (low risk, admin only)
   - Inline "Confirmer?" text swap for per-menu bulk regen (one extra click since bulk is slower)
   - `useTransition()` from React for isPending state on both buttons — button text changes to "En cours..." and becomes disabled while running
   - After successful regen, show brief inline success message ("Enrichi" or count)

Import the Server Actions: `import { regenerateDishEnrichment, regenerateMenuEnrichment } from '@/app/actions/enrichment'`
  </action>
  <verify>
Run `npx tsc --noEmit` — zero type errors. Verify `app/actions/enrichment.ts` exports both `regenerateDishEnrichment` and `regenerateMenuEnrichment`. Verify both have `isAdminAuthenticated()` guard. Verify AdminDashboard imports and calls both Server Actions. Verify `useTransition` provides isPending feedback on regen buttons.
  </verify>
  <done>
Admin panel has per-menu "Ré-enrichir tout" button and per-dish "Régénérer" button. Both call Server Actions behind auth guard. Regen resets enrichment fields, re-runs enrichDishBatch synchronously, and provides visual feedback via useTransition. 80-dish safety cap prevents timeout on large menus. `tsc --noEmit` passes.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds (no build-time import errors from react-modal-sheet or server-only)
3. DishCard shows skeleton shimmer for pending food items, origin pill + hint for full-depth, ingredients for minimal-depth
4. Tapping a full-depth enriched dish opens the bottom sheet with full cultural context
5. Polling hook stops when all food items are enriched or failed
6. Admin "Ré-enrichir tout" resets and re-enriches all food items for a menu
7. Admin "Régénérer" per dish resets and re-enriches a single dish
8. Both admin actions require authentication
</verification>

<success_criteria>
- DishCards progressively update with enrichment data without page reload
- Full-depth dishes show origin + cultural hint on card, full detail in bottom sheet
- Minimal-depth dishes show ingredients inline
- Pending dishes show skeleton shimmer
- Admin can regenerate enrichment per dish and per menu
- All code compiles with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-dish-enrichment/11-02-SUMMARY.md`
</output>
