---
phase: 08-eazee-link-translation-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/types/llm.ts
  - lib/openai.ts
  - lib/cache.ts
  - app/api/scan/url/route.ts
autonomous: true
requirements:
  - DISH-02
gap_closure: true

must_haves:
  truths:
    - "Scanning an eazee-link QR code and switching language shows different translated text for each language (FR/EN/TR/DE)"
    - "The LLM translation step is invoked for eazee-link menus on cache MISS only"
    - "Re-scanning a cached eazee-link menu returns instantly without any LLM call"
    - "source_language is stored in the menus row for eazee-link scans (not null)"
    - "Cultural context is appended to description_translations for dishes with notable origin"
  artifacts:
    - path: "lib/types/llm.ts"
      provides: "Zod schema for eazee-link translation LLM output"
      contains: "eazeeLinkTranslationSchema"
    - path: "lib/openai.ts"
      provides: "translateEazeeLinkDishes function"
      exports: ["translateEazeeLinkDishes", "EAZEE_TRANSLATE_SYSTEM_PROMPT"]
    - path: "lib/cache.ts"
      provides: "getCachedMenu helper + source_language in preParseResult"
      exports: ["getCachedMenu"]
    - path: "app/api/scan/url/route.ts"
      provides: "Cache-aware eazee-link branch with translation before storage"
  key_links:
    - from: "app/api/scan/url/route.ts"
      to: "lib/cache.ts"
      via: "getCachedMenu(canonicalUrl) early return on cache HIT"
      pattern: "getCachedMenu"
    - from: "app/api/scan/url/route.ts"
      to: "lib/openai.ts"
      via: "translateEazeeLinkDishes(dishes, model) on cache MISS"
      pattern: "translateEazeeLinkDishes"
    - from: "app/api/scan/url/route.ts"
      to: "lib/cache.ts"
      via: "getOrParseMenu with { dishes: translatedDishes, source_language }"
      pattern: "source_language"
---

<objective>
Add an LLM translation pass for eazee-link menus so that dish names, descriptions, and cultural context are properly translated into FR/EN/TR/DE before cache storage.

Purpose: Eazee-link menus currently copy the original dish label into all 4 translation slots identically. MenuShell then treats them as "already translated" and never invokes the LLM. This plan fixes the pipeline so each language slot contains a real translation, and adds a cache-check-first pattern to avoid wasting LLM calls on cache hits.

Output: Modified pipeline where eazee-link scans produce genuinely translated dish cards in all 4 languages, with cultural context notes and auto-detected source language.
</objective>

<execution_context>
@/Users/ekitcho/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ekitcho/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-eazee-link-translation-fix/08-RESEARCH.md

@lib/types/llm.ts
@lib/openai.ts
@lib/cache.ts
@app/api/scan/url/route.ts
@lib/menu-providers/eazee-link.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add translation Zod schema, system prompt, and translateEazeeLinkDishes function</name>
  <files>lib/types/llm.ts, lib/openai.ts</files>
  <action>
**In `lib/types/llm.ts`**, add two new Zod schemas after the existing `menuParseSchema`:

1. `eazeeLinkDishTranslationSchema` — schema for a single translated dish:
   - `index`: z.number() — matches input array index for merge
   - `name_translations`: translationMapSchema — FR/EN/TR/DE translations of name
   - `description_translations`: translationMapSchema.nullable() — FR/EN/TR/DE of description, null if no description
   - `cultural_context`: z.string().nullable() — brief cultural note (e.g. "Alsatian thin-crust pizza"), null if not applicable

2. `eazeeLinkMenuTranslationSchema` — top-level schema:
   - `source_language`: z.string() — 2-letter ISO code, auto-detected from dish text
   - `dishes`: z.array(eazeeLinkDishTranslationSchema)

Export both schemas and their inferred types (`EazeeLinkDishTranslation`, `EazeeLinkMenuTranslation`).

CRITICAL: Use `.nullable()` not `.optional()` — OpenAI structured outputs require all properties present.

**In `lib/openai.ts`**, add:

1. `EAZEE_TRANSLATE_SYSTEM_PROMPT` — a translation-only system prompt. Key instructions:
   - Auto-detect source language from dish names/descriptions (do NOT hardcode French per locked decision)
   - Translate each dish name AND description into FR, EN, TR, DE simultaneously (per locked decision: translate both)
   - Add brief `cultural_context` note in English when the dish has notable cultural origin (per locked decision: include cultural context/explanation). Examples: "Alsatian thin-crust pizza", "Provencal fish stew". Return null if no useful context.
   - Do NOT re-extract allergens, prices, or dietary tags — those are already correct from eazee-link API
   - Preserve proper nouns. Keep `index` matching input index exactly.
   - Be concise to minimize token usage (per locked decision: cost optimization priority)

2. `translateEazeeLinkDishes(dishes: DishResponse[], model?: string)` function:
   - Build `dishList` from input: `dishes.map((dish, idx) => ({ index: idx, name: dish.name_original, description: dish.description_original }))`
   - Call `generateText` with `Output.object({ schema: eazeeLinkMenuTranslationSchema })`, `maxRetries: 2`, the new system prompt, and `JSON.stringify(dishList, null, 2)` as the prompt
   - Merge translations back: for each original dish, find matching `output.dishes` entry by index. If found, overwrite `name_translations` and `description_translations`. If `cultural_context` is non-null AND the dish has no `description_original`, set `description_translations` to the cultural context in all 4 language slots (localized). If the dish HAS a `description_original`, append cultural context as a parenthetical suffix to each language's description translation.
   - Fallback: if a dish index is not found in LLM output (partial output — see Pitfall 3 in RESEARCH.md), keep the original untranslated dish
   - Return `{ translatedDishes: DishResponse[], sourceLanguage: string }`
   - Error handling: wrap in try/catch matching the `parseDishesFromMenuFast` pattern. On `NoObjectGeneratedError`, log and throw. Let the caller (route.ts) handle fallback.

Import from `lib/types/llm.ts`: `eazeeLinkMenuTranslationSchema` and the `DishResponse` type.
Use `DEFAULT_LLM_MODEL` as fallback model (same pattern as other functions).
  </action>
  <verify>
1. `npx tsc --noEmit` passes — no type errors in new schemas or function
2. Grep confirms: `eazeeLinkMenuTranslationSchema` exported from `lib/types/llm.ts`
3. Grep confirms: `translateEazeeLinkDishes` exported from `lib/openai.ts`
4. Grep confirms: no `.optional()` in new schema (only `.nullable()`)
  </verify>
  <done>
New Zod schema validates eazee-link translation LLM output with index, name_translations, description_translations, cultural_context, and source_language. New function `translateEazeeLinkDishes` accepts DishResponse[] and returns translated dishes + detected source language using a single batched LLM call.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add getCachedMenu helper and wire cache-aware translation into eazee-link route</name>
  <files>lib/cache.ts, app/api/scan/url/route.ts</files>
  <action>
**In `lib/cache.ts`**, add a `getCachedMenu` helper function (before `getOrParseMenu`):

```typescript
export async function getCachedMenu(url: string): Promise<MenuWithItems | null> {
  const urlHash = hashUrl(url);
  const { data: cached } = await supabase
    .from('menus')
    .select('*, menu_items(*)')
    .eq('url_hash', urlHash)
    .gt('expires_at', new Date().toISOString())
    .maybeSingle();

  if (cached !== null) {
    // Increment hit_count (fire-and-forget)
    supabaseAdmin
      .from('menus')
      .update({ hit_count: (cached.hit_count ?? 0) + 1 })
      .eq('id', cached.id)
      .then(() => {});
    return cached as MenuWithItems;
  }
  return null;
}
```

This is a lightweight cache-check-only helper. It duplicates the cache-hit logic from `getOrParseMenu` intentionally — the alternative (passing a lazy translation callback) adds unnecessary complexity to the cache layer.

Also update `getOrParseMenu`'s `preParseResult` type to accept `source_language` from eazee-link:
- Change the first union variant from `{ dishes: DishResponse[] }` to `{ dishes: DishResponse[]; source_language?: string }`
- The existing `source_language` extraction line (`'source_language' in parsed ? parsed.source_language : null`) will then correctly pick up the eazee-link source language with no further changes needed.

**In `app/api/scan/url/route.ts`**, rewrite the eazee-link branch (Path A) to:

1. Compute `canonicalUrl` (same as now)
2. Call `getCachedMenu(canonicalUrl)` — if cache HIT, return immediately (no LLM call, no fetch)
3. On cache MISS: call `fetchEazeeLinkMenu(eazeeStickerId)` to get dishes + rawText
4. Call `getAdminConfig()` to get the LLM model
5. Call `translateEazeeLinkDishes(dishes, config.llm_model)` to get `{ translatedDishes, sourceLanguage }`
6. Call `getOrParseMenu(canonicalUrl, 'url', rawText, { dishes: translatedDishes, source_language: sourceLanguage })` to store in cache
7. Return `{ menuId: menu.id }`

Wrap steps 3-6 in a try/catch for translation failure fallback:
- If `translateEazeeLinkDishes` throws, log the error and fall back to `getOrParseMenu(canonicalUrl, 'url', rawText, { dishes })` — stores untranslated dishes (same as today). This ensures the user always gets a menu, even if translation fails (per CONTEXT.md: "show untranslated as fallback is acceptable").

Add imports at top of route.ts: `getCachedMenu` from `lib/cache`, `translateEazeeLinkDishes` from `lib/openai`.
  </action>
  <verify>
1. `npx tsc --noEmit` passes — no type errors in route.ts or cache.ts
2. Grep confirms: `getCachedMenu` is called in route.ts BEFORE `fetchEazeeLinkMenu`
3. Grep confirms: `translateEazeeLinkDishes` is called in route.ts AFTER fetch, BEFORE getOrParseMenu
4. Grep confirms: `source_language` is passed in the preParseResult object to getOrParseMenu
5. Grep confirms: try/catch around translation with fallback to untranslated dishes
  </verify>
  <done>
Eazee-link scan route checks cache first (zero LLM cost on re-scan), translates on cache miss via single batched LLM call, stores properly translated dishes with source_language in Supabase. Translation failure falls back gracefully to untranslated dishes.
  </done>
</task>

</tasks>

<verification>
1. **TypeScript compilation**: `npx tsc --noEmit` passes with zero errors
2. **Schema correctness**: `eazeeLinkMenuTranslationSchema` uses `.nullable()` throughout, never `.optional()`
3. **Cache-first pattern**: In route.ts, `getCachedMenu` is called before any fetch or LLM call in the eazee-link branch
4. **Translation call on miss only**: `translateEazeeLinkDishes` is called only after `getCachedMenu` returns null
5. **source_language threaded**: preParseResult passed to `getOrParseMenu` includes `source_language` from translation output
6. **Fallback on error**: Translation failure caught and route falls back to storing untranslated dishes
7. **No new dependencies**: Only uses existing packages (ai, @ai-sdk/openai, zod)
</verification>

<success_criteria>
- Eazee-link menu items in Supabase have distinct translated text per language (not 4 copies of original)
- source_language is non-null in the menus row for eazee-link scans
- Second scan of same eazee-link URL returns cached result with no LLM call
- Translation errors do not crash the scan — untranslated fallback is stored
- TypeScript compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-eazee-link-translation-fix/08-01-SUMMARY.md`
</output>
